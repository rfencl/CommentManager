<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="DeveloperToolsToolWindowSettingsV1" lastSelectedContentNodeId="text-statistic">
    <developerToolsConfigurations>
      <developerToolConfiguration developerToolId="text-statistic" id="406e9a08-0af5-45b3-854e-79bb4037a0b4" name="Workbench">
        <properties>
          <property key="text" type="INPUT" value="kotlin.String|import lombok.SneakyThrows;&#10;import lombok.extern.log4j.Log4j2;&#10;&#10;import java.io.IOException;&#10;import java.nio.file.Path;&#10;import java.nio.file.Paths;&#10;import java.util.*;&#10;&#10;@Log4j2&#10;public class CommentManager {&#10;&#10;    static Map&lt;String, List&lt;String&gt;&gt; combined = new LinkedHashMap&lt;&gt;();&#10;    static Map&lt;Integer, String&gt; classesAndMethods = new LinkedHashMap&lt;&gt;();&#10;    static Map&lt;Integer, List&lt;String&gt;&gt; comments = new LinkedHashMap&lt;&gt;();&#10;    static List&lt;String&gt; lines;&#10;&#10;    @SneakyThrows&#10;    public static void main(String [] args) {&#10;        Path src = Paths.get(args[0]);&#10;        FileUtils.createDocDirectoryStructure(src);&#10;        FileUtils.createMarkDowns(src);&#10;        List&lt;Path&gt; allJavaFiles_src = FileUtils.getAllJavaFiles(src);&#10;&#10;        Path docs = Paths.get(src.toAbsolutePath().toString().replace(&quot;src&quot;, &quot;docs&quot;));&#10;        List&lt;Path&gt; allJavaFiles_docs = FileUtils.getAllMdFiles(docs);&#10;&#10;        // todo loop through all the files and process them&#10;    }&#10;&#10;    /**&#10;     * Remove the java doc comments from the lines of the java source file.&#10;     * @param lines    - lines of java source file&#10;     * @param comments - javadoc comments to remove&#10;     * @return List&lt;String&gt; lines of code without documentation.&#10;     */&#10;    public static List&lt;String&gt; removeJavaDocComments(List&lt;String&gt; lines, Map&lt;Integer, List&lt;String&gt;&gt; comments) {&#10;        List&lt;String&gt; trimmedLines = new LinkedList&lt;&gt;(lines);&#10;        comments.values().forEach(trimmedLines::removeAll);&#10;        trimmedLines.forEach(log::debug);&#10;        return trimmedLines;&#10;    }&#10;&#10;    /**&#10;     * Write the current class comments to markdown&#10;     *&#10;     * @param file&#10;     * @param outputFile&#10;     * @param combined&#10;     */&#10;    public static void writeMarkDown(Path file, Path outputFile, Map&lt;String, List&lt;String&gt;&gt; combined) {&#10;        List&lt;String&gt; markdownLines = new ArrayList&lt;&gt;();&#10;        markdownLines.add(&quot;# &quot; + file.getFileName().toString().replace(&quot;.java&quot;, &quot;&quot;));&#10;        combined.keySet().forEach(methodSignature -&gt; {&#10;            if (methodSignature.contains(&quot;class&quot;)) {&#10;                addCommentsToMarkDown(combined, methodSignature, markdownLines);&#10;                markdownLines.add(&quot;## _Methods_&quot;);&#10;            } else {&#10;                markdownLines.add(boldMethodName(methodSignature, StringUtils.getMethodName(methodSignature.trim())));&#10;                addCommentsToMarkDown(combined, methodSignature, markdownLines);&#10;                markdownLines.add(&quot;---&quot;);&#10;            }&#10;        });&#10;        FileUtils.writeFile(outputFile, markdownLines);&#10;    }&#10;&#10;    private static String boldMethodName(String s, String methodName) {&#10;        return s.trim().replace(methodName, &quot;**&quot; + methodName + &quot;**&quot;);&#10;    }&#10;&#10;    private static void addCommentsToMarkDown(Map&lt;String, List&lt;String&gt;&gt; combined, String s, List&lt;String&gt; markdownLines) {&#10;        combined.get(s).forEach(e -&gt;&#10;                markdownLines.add(&quot;\n\t&quot; + e));&#10;    }&#10;&#10;    /**&#10;     * Restore the javadoc comments to the trimmed file.&#10;     *&#10;     * @param trimmedJavaFile&#10;     * @param markdown&#10;     * @param javaOutputFile&#10;     */&#10;    public static void writeRestoredFile(Path trimmedJavaFile, Path markdown, Path javaOutputFile) {&#10;        List&lt;String&gt; javaLines = FileUtils.readFile(trimmedJavaFile);&#10;        List&lt;String&gt; markdownLines = FileUtils.readFile(markdown);&#10;        Map&lt;Integer, String&gt; declarations = Parser.parseClassAndMethods(javaLines);&#10;        List&lt;Integer&gt; reversed = declarations.keySet().stream().toList().reversed();&#10;        reversed.forEach(lineNumberKey -&gt; {&#10;            String methodDeclaration = declarations.get(lineNumberKey);&#10;            String method = StringUtils.getMethodName(methodDeclaration);&#10;            int methodDeclarationIndex = 0;&#10;            if (!&quot;No method name found.&quot;.equals(method)) {&#10;                String find = methodDeclaration.replace(method, &quot;**&quot; + method + &quot;**&quot;).trim();&#10;                methodDeclarationIndex = markdownLines.indexOf(find);&#10;            }&#10;            List&lt;String&gt; comment = getComment(methodDeclarationIndex, markdownLines);&#10;            if (!comment.isEmpty()) {&#10;                int lineIndex = lineNumberKey-1;&#10;                while(!javaLines.get(lineIndex-1).trim().isEmpty()) { lineIndex--; }&#10;                javaLines.addAll(lineIndex, comment);&#10;            }&#10;&#10;        });&#10;        FileUtils.writeFile(javaOutputFile, javaLines);&#10;    }&#10;&#10;    /**&#10;     * Returns the JavaDoc comments for the method at the given index.&#10;     * @param methodDeclarationIndex - index of the method declaration&#10;     * @param markdownLines - list of markdown lines&#10;     * @return - List&lt;String&gt; - JavaDoc comments&#10;     */&#10;    private static List&lt;String&gt; getComment(int methodDeclarationIndex, List&lt;String&gt; markdownLines) {&#10;        List&lt;String&gt; comment = new ArrayList&lt;&gt;();&#10;        List&lt;String&gt; loopTerminators = List.of(&quot;---&quot;, &quot;## _Methods_&quot;);&#10;        for (int i = methodDeclarationIndex + 1; loopTerminators.stream().noneMatch(markdownLines.get(i)::contains); i++ ) {&#10;            if (markdownLines.get(i).contains(&quot;*&quot;)) {&#10;                comment.add(markdownLines.get(i).replace(&quot;\t&quot;, &quot;&quot;));&#10;            }&#10;        }&#10;        return comment;&#10;    }&#10;&#10;    /**&#10;     * Parse the comments and declarations into maps keyed by line number.&#10;     * @param inputJavaFile&#10;     * @throws IOException&#10;     */&#10;    static void parseFile(String inputJavaFile) throws IOException {&#10;        lines = FileUtils.readFile(FileUtils.getFileFromResources(Path.of(inputJavaFile)));&#10;        classesAndMethods = Parser.parseClassAndMethods(lines);&#10;        comments = Parser.parseJavaDocs(lines);&#10;    }&#10;&#10;    static void combineCommentsAndDeclarations() {&#10;        log.debug(&quot;function keys {}&quot;, classesAndMethods.keySet());&#10;        log.debug(&quot;comment keys {}&quot;, comments.keySet());&#10;        combined = new LinkedHashMap&lt;&gt;();&#10;        Queue&lt;Integer&gt; commentQueue = new LinkedList&lt;&gt;(comments.keySet());&#10;        Queue&lt;Integer&gt; methodQueue = new LinkedList&lt;&gt;(classesAndMethods.keySet());&#10;        List&lt;Integer&gt; methodsWithoutComments = new ArrayList&lt;&gt;();&#10;        while(!methodQueue.isEmpty()) {&#10;            int fi = methodQueue.poll();&#10;            int startCount = commentQueue.size();&#10;            for (Integer li : commentQueue) {&#10;                if (li &lt; fi) {&#10;                    combined.put(classesAndMethods.get(fi), comments.get(li));&#10;                    commentQueue.remove();&#10;                    break;&#10;                }&#10;            }&#10;            if (commentQueue.size() == startCount) {&#10;                methodsWithoutComments.add(fi);&#10;            }&#10;        }&#10;&#10;        addDefaultMessageToMethodsWithoutComments(methodsWithoutComments);&#10;    }&#10;&#10;    /**&#10;     * Build a new map by inserting methods without a comment back into their correct place&#10;     * with a default message.&#10;     * @param methodsWithoutComments&#10;     */&#10;    static void addDefaultMessageToMethodsWithoutComments(List&lt;Integer&gt; methodsWithoutComments) {&#10;        Map&lt;String, List&lt;String&gt;&gt; newMap = new LinkedHashMap&lt;&gt;();&#10;        Queue&lt;String&gt; methods = new LinkedList&lt;&gt;(combined.keySet());&#10;        while (!methodsWithoutComments.isEmpty()) {&#10;            int mwcIndex = methodsWithoutComments.getFirst();&#10;            int currentIndexOfCombined = getIndexOfMethodWithComment(methods.peek(), classesAndMethods);&#10;            if (isInsertMethodWithDefaultJavaDoc(currentIndexOfCombined, mwcIndex)) {&#10;                newMap.put(classesAndMethods.get(mwcIndex), List.of(&quot;\tNo JavaDoc Comments Found.&quot;));&#10;                methodsWithoutComments.removeFirst();&#10;            } else {&#10;                String methodName = methods.poll();&#10;                newMap.put(methodName, combined.get(methodName));&#10;            }&#10;        }&#10;        if (!newMap.isEmpty()) {&#10;            combined = newMap;&#10;        }&#10;    }&#10;&#10;    private static boolean isInsertMethodWithDefaultJavaDoc(int currentIndexOfCombined, int mwcIndex) {&#10;        return currentIndexOfCombined == -1 || mwcIndex &lt; currentIndexOfCombined;&#10;    }&#10;&#10;    static int getIndexOfMethodWithComment(String method, Map&lt;Integer, String&gt; classesAndMethods) {&#10;        Integer keyByValue = MapUtils.findKeyByValue(classesAndMethods, method);&#10;        return null == keyByValue ? -1 : keyByValue ;&#10;    }&#10;}&#10;" />
        </properties>
      </developerToolConfiguration>
    </developerToolsConfigurations>
  </component>
</project>